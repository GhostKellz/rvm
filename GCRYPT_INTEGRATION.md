# RVM (Rust Virtual Machine) C/C++ Integration Guide

Complete guide for using RVM from C and C++ projects via C FFI bindings.

## Table of Contents

- [Overview](#overview)
- [Building C Bindings](#building-c-bindings)
- [C Usage](#c-usage)
- [C++ Wrapper](#c-wrapper)
- [CMake Integration](#cmake-integration)
- [VM Operations](#vm-operations)
- [Smart Contract Execution](#smart-contract-execution)
- [Error Handling](#error-handling)

## Overview

RVM provides C bindings for virtual machine operations, allowing C and C++ applications to execute smart contracts, manage blockchain state, and interact with decentralized applications. The bindings maintain performance and security while providing familiar APIs for VM management and contract execution.

## Building C Bindings

### Rust Library Setup

Configure the Rust project for C-compatible binaries:

```toml
# Cargo.toml
[package]
name = "rvm-c"
version = "0.1.0"
edition = "2021"

[lib]
name = "rvm_c"
crate-type = ["cdylib", "staticlib"]

[dependencies]
rvm = { version = "0.1", features = ["std", "wasm", "evm"] }
gcrypt = { version = "0.2", features = ["ed25519", "secp256k1", "blake3"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
hex = "0.4"
libc = "0.2"

[build-dependencies]
cbindgen = "0.24"
```

### Build Script for Header Generation

```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_dir = PathBuf::from(&crate_dir).join("include");

    std::fs::create_dir_all(&output_dir).unwrap();

    let output_file = output_dir.join("rvm.h");

    cbindgen::Builder::new()
        .with_crate(crate_dir)
        .with_language(cbindgen::Language::C)
        .with_include_guard("RVM_H")
        .with_documentation(true)
        .with_autogen_warning("/* Auto-generated by cbindgen */")
        .generate()
        .expect("Unable to generate bindings")
        .write_to_file(output_file);

    println!("cargo:rerun-if-changed=src/lib.rs");
}
```

### C FFI Implementation

```rust
// src/lib.rs
use rvm::{VM, VMConfig, Contract, Account, Transaction, ExecutionResult};
use gcrypt::protocols::{Ed25519, Secp256k1};
use serde::{Serialize, Deserialize};
use std::ptr;
use std::slice;
use std::ffi::{c_char, c_int, c_uint, c_void, CStr, CString};
use libc::size_t;
use std::collections::HashMap;

// Error codes
pub const RVM_SUCCESS: c_int = 0;
pub const RVM_ERROR_INVALID_INPUT: c_int = -1;
pub const RVM_ERROR_EXECUTION_FAILED: c_int = -2;
pub const RVM_ERROR_OUT_OF_GAS: c_int = -3;
pub const RVM_ERROR_CONTRACT_NOT_FOUND: c_int = -4;
pub const RVM_ERROR_INVALID_BYTECODE: c_int = -5;
pub const RVM_ERROR_REVERT: c_int = -6;
pub const RVM_ERROR_OUT_OF_MEMORY: c_int = -7;
pub const RVM_ERROR_SERIALIZATION_FAILED: c_int = -8;
pub const RVM_ERROR_STACK_OVERFLOW: c_int = -9;
pub const RVM_ERROR_STACK_UNDERFLOW: c_int = -10;

// VM Types
pub const RVM_VM_TYPE_EVM: c_int = 1;
pub const RVM_VM_TYPE_WASM: c_int = 2;
pub const RVM_VM_TYPE_GHOST: c_int = 3;

// Account types
pub const RVM_ACCOUNT_TYPE_EOA: c_int = 1; // Externally Owned Account
pub const RVM_ACCOUNT_TYPE_CONTRACT: c_int = 2;

// Transaction types
pub const RVM_TX_TYPE_CALL: c_int = 1;
pub const RVM_TX_TYPE_CREATE: c_int = 2;
pub const RVM_TX_TYPE_CREATE2: c_int = 3;

// Execution status
pub const RVM_EXEC_SUCCESS: c_int = 0;
pub const RVM_EXEC_REVERT: c_int = 1;
pub const RVM_EXEC_OUT_OF_GAS: c_int = 2;
pub const RVM_EXEC_INVALID_OPCODE: c_int = 3;
pub const RVM_EXEC_STACK_OVERFLOW: c_int = 4;
pub const RVM_EXEC_STACK_UNDERFLOW: c_int = 5;

// Opaque handle types
#[repr(C)]
pub struct rvm_vm_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct rvm_account_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct rvm_contract_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct rvm_transaction_t {
    _private: [u8; 0],
}

#[repr(C)]
pub struct rvm_execution_result_t {
    _private: [u8; 0],
}

// Configuration structure
#[repr(C)]
#[derive(Debug, Clone)]
pub struct rvm_config_t {
    pub vm_type: c_int,
    pub max_gas_limit: u64,
    pub max_stack_size: u32,
    pub max_memory_size: u64,
    pub enable_precompiles: c_int, // bool
    pub enable_debug: c_int, // bool
    pub gas_price: u64,
    pub chain_id: u64,
}

impl Default for rvm_config_t {
    fn default() -> Self {
        Self {
            vm_type: RVM_VM_TYPE_EVM,
            max_gas_limit: 30000000,
            max_stack_size: 1024,
            max_memory_size: 128 * 1024 * 1024, // 128 MB
            enable_precompiles: 1,
            enable_debug: 0,
            gas_price: 20000000000, // 20 gwei
            chain_id: 1,
        }
    }
}

// Account information
#[repr(C)]
#[derive(Debug, Clone)]
pub struct rvm_account_info_t {
    pub address: [u8; 20],
    pub balance: [u8; 32], // U256 in big-endian
    pub nonce: u64,
    pub account_type: c_int,
    pub code_hash: [u8; 32],
    pub storage_root: [u8; 32],
}

// Contract information
#[repr(C)]
#[derive(Debug, Clone)]
pub struct rvm_contract_info_t {
    pub address: [u8; 20],
    pub deployer: [u8; 20],
    pub code_size: size_t,
    pub storage_size: size_t,
    pub created_at_block: u64,
}

// Transaction information
#[repr(C)]
#[derive(Debug, Clone)]
pub struct rvm_transaction_info_t {
    pub tx_type: c_int,
    pub from: [u8; 20],
    pub to: [u8; 20],
    pub value: [u8; 32], // U256 in big-endian
    pub gas_limit: u64,
    pub gas_price: u64,
    pub nonce: u64,
    pub data_size: size_t,
}

// Execution result
#[repr(C)]
#[derive(Debug, Clone)]
pub struct rvm_execution_info_t {
    pub status: c_int,
    pub gas_used: u64,
    pub gas_remaining: u64,
    pub return_data_size: size_t,
    pub logs_count: size_t,
    pub created_contract: [u8; 20], // If contract creation
    pub revert_reason_size: size_t,
}

// Log entry
#[repr(C)]
#[derive(Debug, Clone)]
pub struct rvm_log_entry_t {
    pub address: [u8; 20],
    pub topics_count: size_t,
    pub data_size: size_t,
}

// Internal structures
struct InternalVM {
    vm: VM,
    config: VMConfig,
}

struct InternalAccount {
    account: Account,
}

struct InternalContract {
    contract: Contract,
}

struct InternalTransaction {
    transaction: Transaction,
}

struct InternalExecutionResult {
    result: ExecutionResult,
}

// Version information
#[no_mangle]
pub extern "C" fn rvm_version_string() -> *const c_char {
    b"rvm 0.1.0\0".as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn rvm_version_major() -> c_uint {
    0
}

#[no_mangle]
pub extern "C" fn rvm_version_minor() -> c_uint {
    1
}

#[no_mangle]
pub extern "C" fn rvm_version_patch() -> c_uint {
    0
}

// VM management
#[no_mangle]
pub extern "C" fn rvm_vm_new(config: *const rvm_config_t) -> *mut rvm_vm_t {
    let cfg = if config.is_null() {
        rvm_config_t::default()
    } else {
        unsafe { *config }
    };

    // Convert C config to Rust config
    let vm_config = VMConfig {
        vm_type: match cfg.vm_type {
            RVM_VM_TYPE_EVM => rvm::VMType::EVM,
            RVM_VM_TYPE_WASM => rvm::VMType::WASM,
            RVM_VM_TYPE_GHOST => rvm::VMType::Ghost,
            _ => rvm::VMType::EVM,
        },
        max_gas_limit: cfg.max_gas_limit,
        max_stack_size: cfg.max_stack_size,
        max_memory_size: cfg.max_memory_size,
        enable_precompiles: cfg.enable_precompiles != 0,
        enable_debug: cfg.enable_debug != 0,
        gas_price: cfg.gas_price,
        chain_id: cfg.chain_id,
    };

    let vm = match VM::new(vm_config.clone()) {
        Ok(v) => v,
        Err(_) => return ptr::null_mut(),
    };

    let internal_vm = InternalVM {
        vm,
        config: vm_config,
    };

    let boxed = Box::new(internal_vm);
    Box::into_raw(boxed) as *mut rvm_vm_t
}

#[no_mangle]
pub extern "C" fn rvm_vm_free(vm: *mut rvm_vm_t) {
    if !vm.is_null() {
        unsafe {
            let _ = Box::from_raw(vm as *mut InternalVM);
        }
    }
}

// Account management
#[no_mangle]
pub extern "C" fn rvm_account_create(
    vm: *mut rvm_vm_t,
    address: *const u8,
    balance: *const u8,
    nonce: u64,
) -> *mut rvm_account_t {
    if vm.is_null() || address.is_null() {
        return ptr::null_mut();
    }

    let internal_vm = unsafe { &mut *(vm as *mut InternalVM) };

    let addr_slice = unsafe { slice::from_raw_parts(address, 20) };
    let mut addr_array = [0u8; 20];
    addr_array.copy_from_slice(addr_slice);

    let balance_value = if balance.is_null() {
        [0u8; 32]
    } else {
        let balance_slice = unsafe { slice::from_raw_parts(balance, 32) };
        let mut balance_array = [0u8; 32];
        balance_array.copy_from_slice(balance_slice);
        balance_array
    };

    let account = match Account::new(addr_array, balance_value, nonce) {
        Ok(acc) => acc,
        Err(_) => return ptr::null_mut(),
    };

    let internal_account = InternalAccount { account };
    let boxed = Box::new(internal_account);
    Box::into_raw(boxed) as *mut rvm_account_t
}

#[no_mangle]
pub extern "C" fn rvm_account_get_info(
    account: *mut rvm_account_t,
    info: *mut rvm_account_info_t,
) -> c_int {
    if account.is_null() || info.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_account = unsafe { &*(account as *mut InternalAccount) };

    unsafe {
        (*info).address = internal_account.account.address();
        (*info).balance = internal_account.account.balance();
        (*info).nonce = internal_account.account.nonce();
        (*info).account_type = if internal_account.account.is_contract() {
            RVM_ACCOUNT_TYPE_CONTRACT
        } else {
            RVM_ACCOUNT_TYPE_EOA
        };
        (*info).code_hash = internal_account.account.code_hash();
        (*info).storage_root = internal_account.account.storage_root();
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_account_set_balance(
    account: *mut rvm_account_t,
    balance: *const u8,
) -> c_int {
    if account.is_null() || balance.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_account = unsafe { &mut *(account as *mut InternalAccount) };
    let balance_slice = unsafe { slice::from_raw_parts(balance, 32) };
    let mut balance_array = [0u8; 32];
    balance_array.copy_from_slice(balance_slice);

    match internal_account.account.set_balance(balance_array) {
        Ok(_) => RVM_SUCCESS,
        Err(_) => RVM_ERROR_EXECUTION_FAILED,
    }
}

#[no_mangle]
pub extern "C" fn rvm_account_increment_nonce(account: *mut rvm_account_t) -> c_int {
    if account.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_account = unsafe { &mut *(account as *mut InternalAccount) };
    internal_account.account.increment_nonce();
    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_account_free(account: *mut rvm_account_t) {
    if !account.is_null() {
        unsafe {
            let _ = Box::from_raw(account as *mut InternalAccount);
        }
    }
}

// Contract management
#[no_mangle]
pub extern "C" fn rvm_contract_deploy(
    vm: *mut rvm_vm_t,
    deployer: *const u8,
    bytecode: *const u8,
    bytecode_len: size_t,
    constructor_args: *const u8,
    constructor_args_len: size_t,
    gas_limit: u64,
) -> *mut rvm_contract_t {
    if vm.is_null() || deployer.is_null() || bytecode.is_null() {
        return ptr::null_mut();
    }

    let internal_vm = unsafe { &mut *(vm as *mut InternalVM) };

    let deployer_slice = unsafe { slice::from_raw_parts(deployer, 20) };
    let mut deployer_array = [0u8; 20];
    deployer_array.copy_from_slice(deployer_slice);

    let bytecode_slice = unsafe { slice::from_raw_parts(bytecode, bytecode_len) };

    let constructor_data = if constructor_args.is_null() {
        vec![]
    } else {
        unsafe { slice::from_raw_parts(constructor_args, constructor_args_len).to_vec() }
    };

    let contract = match Contract::deploy(
        &mut internal_vm.vm,
        deployer_array,
        bytecode_slice.to_vec(),
        constructor_data,
        gas_limit,
    ) {
        Ok(c) => c,
        Err(_) => return ptr::null_mut(),
    };

    let internal_contract = InternalContract { contract };
    let boxed = Box::new(internal_contract);
    Box::into_raw(boxed) as *mut rvm_contract_t
}

#[no_mangle]
pub extern "C" fn rvm_contract_call(
    vm: *mut rvm_vm_t,
    contract: *mut rvm_contract_t,
    caller: *const u8,
    function_data: *const u8,
    function_data_len: size_t,
    value: *const u8,
    gas_limit: u64,
) -> *mut rvm_execution_result_t {
    if vm.is_null() || contract.is_null() || caller.is_null() {
        return ptr::null_mut();
    }

    let internal_vm = unsafe { &mut *(vm as *mut InternalVM) };
    let internal_contract = unsafe { &*(contract as *mut InternalContract) };

    let caller_slice = unsafe { slice::from_raw_parts(caller, 20) };
    let mut caller_array = [0u8; 20];
    caller_array.copy_from_slice(caller_slice);

    let call_data = if function_data.is_null() {
        vec![]
    } else {
        unsafe { slice::from_raw_parts(function_data, function_data_len).to_vec() }
    };

    let value_array = if value.is_null() {
        [0u8; 32]
    } else {
        let value_slice = unsafe { slice::from_raw_parts(value, 32) };
        let mut value_array = [0u8; 32];
        value_array.copy_from_slice(value_slice);
        value_array
    };

    let result = match internal_contract.contract.call(
        &mut internal_vm.vm,
        caller_array,
        call_data,
        value_array,
        gas_limit,
    ) {
        Ok(r) => r,
        Err(_) => return ptr::null_mut(),
    };

    let internal_result = InternalExecutionResult { result };
    let boxed = Box::new(internal_result);
    Box::into_raw(boxed) as *mut rvm_execution_result_t
}

#[no_mangle]
pub extern "C" fn rvm_contract_get_info(
    contract: *mut rvm_contract_t,
    info: *mut rvm_contract_info_t,
) -> c_int {
    if contract.is_null() || info.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_contract = unsafe { &*(contract as *mut InternalContract) };

    unsafe {
        (*info).address = internal_contract.contract.address();
        (*info).deployer = internal_contract.contract.deployer();
        (*info).code_size = internal_contract.contract.code().len();
        (*info).storage_size = internal_contract.contract.storage_size();
        (*info).created_at_block = internal_contract.contract.created_at_block();
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_contract_get_code(
    contract: *mut rvm_contract_t,
    code_buffer: *mut u8,
    buffer_size: size_t,
    actual_size: *mut size_t,
) -> c_int {
    if contract.is_null() || actual_size.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_contract = unsafe { &*(contract as *mut InternalContract) };
    let code = internal_contract.contract.code();

    unsafe {
        *actual_size = code.len();
    }

    if !code_buffer.is_null() && buffer_size >= code.len() {
        unsafe {
            let buffer_slice = slice::from_raw_parts_mut(code_buffer, buffer_size);
            buffer_slice[..code.len()].copy_from_slice(code);
        }
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_contract_free(contract: *mut rvm_contract_t) {
    if !contract.is_null() {
        unsafe {
            let _ = Box::from_raw(contract as *mut InternalContract);
        }
    }
}

// Transaction management
#[no_mangle]
pub extern "C" fn rvm_transaction_create(
    tx_type: c_int,
    from: *const u8,
    to: *const u8,
    value: *const u8,
    gas_limit: u64,
    gas_price: u64,
    nonce: u64,
    data: *const u8,
    data_len: size_t,
) -> *mut rvm_transaction_t {
    if from.is_null() {
        return ptr::null_mut();
    }

    let from_slice = unsafe { slice::from_raw_parts(from, 20) };
    let mut from_array = [0u8; 20];
    from_array.copy_from_slice(from_slice);

    let to_array = if to.is_null() {
        [0u8; 20] // Contract creation
    } else {
        let to_slice = unsafe { slice::from_raw_parts(to, 20) };
        let mut to_array = [0u8; 20];
        to_array.copy_from_slice(to_slice);
        to_array
    };

    let value_array = if value.is_null() {
        [0u8; 32]
    } else {
        let value_slice = unsafe { slice::from_raw_parts(value, 32) };
        let mut value_array = [0u8; 32];
        value_array.copy_from_slice(value_slice);
        value_array
    };

    let tx_data = if data.is_null() {
        vec![]
    } else {
        unsafe { slice::from_raw_parts(data, data_len).to_vec() }
    };

    let transaction = Transaction::new(
        match tx_type {
            RVM_TX_TYPE_CALL => rvm::TransactionType::Call,
            RVM_TX_TYPE_CREATE => rvm::TransactionType::Create,
            RVM_TX_TYPE_CREATE2 => rvm::TransactionType::Create2,
            _ => rvm::TransactionType::Call,
        },
        from_array,
        to_array,
        value_array,
        gas_limit,
        gas_price,
        nonce,
        tx_data,
    );

    let internal_transaction = InternalTransaction { transaction };
    let boxed = Box::new(internal_transaction);
    Box::into_raw(boxed) as *mut rvm_transaction_t
}

#[no_mangle]
pub extern "C" fn rvm_transaction_execute(
    vm: *mut rvm_vm_t,
    transaction: *mut rvm_transaction_t,
) -> *mut rvm_execution_result_t {
    if vm.is_null() || transaction.is_null() {
        return ptr::null_mut();
    }

    let internal_vm = unsafe { &mut *(vm as *mut InternalVM) };
    let internal_transaction = unsafe { &*(transaction as *mut InternalTransaction) };

    let result = match internal_vm.vm.execute_transaction(&internal_transaction.transaction) {
        Ok(r) => r,
        Err(_) => return ptr::null_mut(),
    };

    let internal_result = InternalExecutionResult { result };
    let boxed = Box::new(internal_result);
    Box::into_raw(boxed) as *mut rvm_execution_result_t
}

#[no_mangle]
pub extern "C" fn rvm_transaction_get_info(
    transaction: *mut rvm_transaction_t,
    info: *mut rvm_transaction_info_t,
) -> c_int {
    if transaction.is_null() || info.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_transaction = unsafe { &*(transaction as *mut InternalTransaction) };

    unsafe {
        (*info).tx_type = match internal_transaction.transaction.tx_type() {
            rvm::TransactionType::Call => RVM_TX_TYPE_CALL,
            rvm::TransactionType::Create => RVM_TX_TYPE_CREATE,
            rvm::TransactionType::Create2 => RVM_TX_TYPE_CREATE2,
        };
        (*info).from = internal_transaction.transaction.from();
        (*info).to = internal_transaction.transaction.to();
        (*info).value = internal_transaction.transaction.value();
        (*info).gas_limit = internal_transaction.transaction.gas_limit();
        (*info).gas_price = internal_transaction.transaction.gas_price();
        (*info).nonce = internal_transaction.transaction.nonce();
        (*info).data_size = internal_transaction.transaction.data().len();
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_transaction_free(transaction: *mut rvm_transaction_t) {
    if !transaction.is_null() {
        unsafe {
            let _ = Box::from_raw(transaction as *mut InternalTransaction);
        }
    }
}

// Execution result management
#[no_mangle]
pub extern "C" fn rvm_execution_result_get_info(
    result: *mut rvm_execution_result_t,
    info: *mut rvm_execution_info_t,
) -> c_int {
    if result.is_null() || info.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_result = unsafe { &*(result as *mut InternalExecutionResult) };

    unsafe {
        (*info).status = match internal_result.result.status() {
            rvm::ExecutionStatus::Success => RVM_EXEC_SUCCESS,
            rvm::ExecutionStatus::Revert => RVM_EXEC_REVERT,
            rvm::ExecutionStatus::OutOfGas => RVM_EXEC_OUT_OF_GAS,
            rvm::ExecutionStatus::InvalidOpcode => RVM_EXEC_INVALID_OPCODE,
            rvm::ExecutionStatus::StackOverflow => RVM_EXEC_STACK_OVERFLOW,
            rvm::ExecutionStatus::StackUnderflow => RVM_EXEC_STACK_UNDERFLOW,
        };
        (*info).gas_used = internal_result.result.gas_used();
        (*info).gas_remaining = internal_result.result.gas_remaining();
        (*info).return_data_size = internal_result.result.return_data().len();
        (*info).logs_count = internal_result.result.logs().len();
        (*info).created_contract = internal_result.result.created_contract().unwrap_or([0u8; 20]);
        (*info).revert_reason_size = internal_result.result.revert_reason()
            .map(|r| r.len())
            .unwrap_or(0);
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_execution_result_get_return_data(
    result: *mut rvm_execution_result_t,
    data_buffer: *mut u8,
    buffer_size: size_t,
    actual_size: *mut size_t,
) -> c_int {
    if result.is_null() || actual_size.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_result = unsafe { &*(result as *mut InternalExecutionResult) };
    let return_data = internal_result.result.return_data();

    unsafe {
        *actual_size = return_data.len();
    }

    if !data_buffer.is_null() && buffer_size >= return_data.len() {
        unsafe {
            let buffer_slice = slice::from_raw_parts_mut(data_buffer, buffer_size);
            buffer_slice[..return_data.len()].copy_from_slice(return_data);
        }
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_execution_result_get_logs(
    result: *mut rvm_execution_result_t,
    logs_buffer: *mut rvm_log_entry_t,
    buffer_count: size_t,
    actual_count: *mut size_t,
) -> c_int {
    if result.is_null() || actual_count.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_result = unsafe { &*(result as *mut InternalExecutionResult) };
    let logs = internal_result.result.logs();

    unsafe {
        *actual_count = logs.len();
    }

    if !logs_buffer.is_null() && buffer_count >= logs.len() {
        for (i, log) in logs.iter().enumerate() {
            unsafe {
                let log_entry = logs_buffer.add(i);
                (*log_entry).address = log.address();
                (*log_entry).topics_count = log.topics().len();
                (*log_entry).data_size = log.data().len();
            }
        }
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_execution_result_free(result: *mut rvm_execution_result_t) {
    if !result.is_null() {
        unsafe {
            let _ = Box::from_raw(result as *mut InternalExecutionResult);
        }
    }
}

// Utility functions
#[no_mangle]
pub extern "C" fn rvm_error_string(error_code: c_int) -> *const c_char {
    match error_code {
        RVM_SUCCESS => b"Success\0",
        RVM_ERROR_INVALID_INPUT => b"Invalid input\0",
        RVM_ERROR_EXECUTION_FAILED => b"Execution failed\0",
        RVM_ERROR_OUT_OF_GAS => b"Out of gas\0",
        RVM_ERROR_CONTRACT_NOT_FOUND => b"Contract not found\0",
        RVM_ERROR_INVALID_BYTECODE => b"Invalid bytecode\0",
        RVM_ERROR_REVERT => b"Transaction reverted\0",
        RVM_ERROR_OUT_OF_MEMORY => b"Out of memory\0",
        RVM_ERROR_SERIALIZATION_FAILED => b"Serialization failed\0",
        RVM_ERROR_STACK_OVERFLOW => b"Stack overflow\0",
        RVM_ERROR_STACK_UNDERFLOW => b"Stack underflow\0",
        _ => b"Unknown error\0",
    }.as_ptr() as *const c_char
}

#[no_mangle]
pub extern "C" fn rvm_vm_type_name(vm_type: c_int) -> *const c_char {
    match vm_type {
        RVM_VM_TYPE_EVM => b"Ethereum Virtual Machine\0",
        RVM_VM_TYPE_WASM => b"WebAssembly\0",
        RVM_VM_TYPE_GHOST => b"GhostChain VM\0",
        _ => b"Unknown\0",
    }.as_ptr() as *const c_char
}

// Gas estimation
#[no_mangle]
pub extern "C" fn rvm_estimate_gas(
    vm: *mut rvm_vm_t,
    transaction: *mut rvm_transaction_t,
    estimated_gas: *mut u64,
) -> c_int {
    if vm.is_null() || transaction.is_null() || estimated_gas.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_vm = unsafe { &mut *(vm as *mut InternalVM) };
    let internal_transaction = unsafe { &*(transaction as *mut InternalTransaction) };

    match internal_vm.vm.estimate_gas(&internal_transaction.transaction) {
        Ok(gas) => {
            unsafe {
                *estimated_gas = gas;
            }
            RVM_SUCCESS
        }
        Err(_) => RVM_ERROR_EXECUTION_FAILED,
    }
}

// State management
#[no_mangle]
pub extern "C" fn rvm_vm_get_state_root(
    vm: *mut rvm_vm_t,
    root_hash: *mut u8,
) -> c_int {
    if vm.is_null() || root_hash.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_vm = unsafe { &*(vm as *mut InternalVM) };
    let state_root = internal_vm.vm.state_root();

    unsafe {
        let root_slice = slice::from_raw_parts_mut(root_hash, 32);
        root_slice.copy_from_slice(&state_root);
    }

    RVM_SUCCESS
}

#[no_mangle]
pub extern "C" fn rvm_vm_commit_state(vm: *mut rvm_vm_t) -> c_int {
    if vm.is_null() {
        return RVM_ERROR_INVALID_INPUT;
    }

    let internal_vm = unsafe { &mut *(vm as *mut InternalVM) };

    match internal_vm.vm.commit_state() {
        Ok(_) => RVM_SUCCESS,
        Err(_) => RVM_ERROR_EXECUTION_FAILED,
    }
}
```

### Generated C Header

```c
/* Auto-generated by cbindgen */

#ifndef RVM_H
#define RVM_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Error codes
 */
#define RVM_SUCCESS 0
#define RVM_ERROR_INVALID_INPUT -1
#define RVM_ERROR_EXECUTION_FAILED -2
#define RVM_ERROR_OUT_OF_GAS -3
#define RVM_ERROR_CONTRACT_NOT_FOUND -4
#define RVM_ERROR_INVALID_BYTECODE -5
#define RVM_ERROR_REVERT -6
#define RVM_ERROR_OUT_OF_MEMORY -7
#define RVM_ERROR_SERIALIZATION_FAILED -8
#define RVM_ERROR_STACK_OVERFLOW -9
#define RVM_ERROR_STACK_UNDERFLOW -10

/**
 * VM Types
 */
#define RVM_VM_TYPE_EVM 1
#define RVM_VM_TYPE_WASM 2
#define RVM_VM_TYPE_GHOST 3

/**
 * Account types
 */
#define RVM_ACCOUNT_TYPE_EOA 1
#define RVM_ACCOUNT_TYPE_CONTRACT 2

/**
 * Transaction types
 */
#define RVM_TX_TYPE_CALL 1
#define RVM_TX_TYPE_CREATE 2
#define RVM_TX_TYPE_CREATE2 3

/**
 * Execution status
 */
#define RVM_EXEC_SUCCESS 0
#define RVM_EXEC_REVERT 1
#define RVM_EXEC_OUT_OF_GAS 2
#define RVM_EXEC_INVALID_OPCODE 3
#define RVM_EXEC_STACK_OVERFLOW 4
#define RVM_EXEC_STACK_UNDERFLOW 5

/**
 * Opaque VM handle
 */
typedef struct rvm_vm_t rvm_vm_t;

/**
 * Opaque account handle
 */
typedef struct rvm_account_t rvm_account_t;

/**
 * Opaque contract handle
 */
typedef struct rvm_contract_t rvm_contract_t;

/**
 * Opaque transaction handle
 */
typedef struct rvm_transaction_t rvm_transaction_t;

/**
 * Opaque execution result handle
 */
typedef struct rvm_execution_result_t rvm_execution_result_t;

/**
 * VM configuration
 */
typedef struct rvm_config_t {
  int vm_type;
  uint64_t max_gas_limit;
  uint32_t max_stack_size;
  uint64_t max_memory_size;
  int enable_precompiles;
  int enable_debug;
  uint64_t gas_price;
  uint64_t chain_id;
} rvm_config_t;

/**
 * Account information
 */
typedef struct rvm_account_info_t {
  uint8_t address[20];
  uint8_t balance[32];
  uint64_t nonce;
  int account_type;
  uint8_t code_hash[32];
  uint8_t storage_root[32];
} rvm_account_info_t;

/**
 * Contract information
 */
typedef struct rvm_contract_info_t {
  uint8_t address[20];
  uint8_t deployer[20];
  size_t code_size;
  size_t storage_size;
  uint64_t created_at_block;
} rvm_contract_info_t;

/**
 * Transaction information
 */
typedef struct rvm_transaction_info_t {
  int tx_type;
  uint8_t from[20];
  uint8_t to[20];
  uint8_t value[32];
  uint64_t gas_limit;
  uint64_t gas_price;
  uint64_t nonce;
  size_t data_size;
} rvm_transaction_info_t;

/**
 * Execution result information
 */
typedef struct rvm_execution_info_t {
  int status;
  uint64_t gas_used;
  uint64_t gas_remaining;
  size_t return_data_size;
  size_t logs_count;
  uint8_t created_contract[20];
  size_t revert_reason_size;
} rvm_execution_info_t;

/**
 * Log entry
 */
typedef struct rvm_log_entry_t {
  uint8_t address[20];
  size_t topics_count;
  size_t data_size;
} rvm_log_entry_t;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Get RVM version string
 */
const char *rvm_version_string(void);

/**
 * Get major version number
 */
unsigned int rvm_version_major(void);

/**
 * Get minor version number
 */
unsigned int rvm_version_minor(void);

/**
 * Get patch version number
 */
unsigned int rvm_version_patch(void);

/**
 * Create a new VM instance
 */
rvm_vm_t *rvm_vm_new(const rvm_config_t *config);

/**
 * Free VM instance
 */
void rvm_vm_free(rvm_vm_t *vm);

/**
 * Create a new account
 */
rvm_account_t *rvm_account_create(rvm_vm_t *vm,
                                 const uint8_t *address,
                                 const uint8_t *balance,
                                 uint64_t nonce);

/**
 * Get account information
 */
int rvm_account_get_info(rvm_account_t *account, rvm_account_info_t *info);

/**
 * Set account balance
 */
int rvm_account_set_balance(rvm_account_t *account, const uint8_t *balance);

/**
 * Increment account nonce
 */
int rvm_account_increment_nonce(rvm_account_t *account);

/**
 * Free account
 */
void rvm_account_free(rvm_account_t *account);

/**
 * Deploy a contract
 */
rvm_contract_t *rvm_contract_deploy(rvm_vm_t *vm,
                                   const uint8_t *deployer,
                                   const uint8_t *bytecode,
                                   size_t bytecode_len,
                                   const uint8_t *constructor_args,
                                   size_t constructor_args_len,
                                   uint64_t gas_limit);

/**
 * Call a contract function
 */
rvm_execution_result_t *rvm_contract_call(rvm_vm_t *vm,
                                         rvm_contract_t *contract,
                                         const uint8_t *caller,
                                         const uint8_t *function_data,
                                         size_t function_data_len,
                                         const uint8_t *value,
                                         uint64_t gas_limit);

/**
 * Get contract information
 */
int rvm_contract_get_info(rvm_contract_t *contract, rvm_contract_info_t *info);

/**
 * Get contract bytecode
 */
int rvm_contract_get_code(rvm_contract_t *contract,
                         uint8_t *code_buffer,
                         size_t buffer_size,
                         size_t *actual_size);

/**
 * Free contract
 */
void rvm_contract_free(rvm_contract_t *contract);

/**
 * Create a transaction
 */
rvm_transaction_t *rvm_transaction_create(int tx_type,
                                         const uint8_t *from,
                                         const uint8_t *to,
                                         const uint8_t *value,
                                         uint64_t gas_limit,
                                         uint64_t gas_price,
                                         uint64_t nonce,
                                         const uint8_t *data,
                                         size_t data_len);

/**
 * Execute a transaction
 */
rvm_execution_result_t *rvm_transaction_execute(rvm_vm_t *vm,
                                               rvm_transaction_t *transaction);

/**
 * Get transaction information
 */
int rvm_transaction_get_info(rvm_transaction_t *transaction,
                           rvm_transaction_info_t *info);

/**
 * Free transaction
 */
void rvm_transaction_free(rvm_transaction_t *transaction);

/**
 * Get execution result information
 */
int rvm_execution_result_get_info(rvm_execution_result_t *result,
                                 rvm_execution_info_t *info);

/**
 * Get execution return data
 */
int rvm_execution_result_get_return_data(rvm_execution_result_t *result,
                                        uint8_t *data_buffer,
                                        size_t buffer_size,
                                        size_t *actual_size);

/**
 * Get execution logs
 */
int rvm_execution_result_get_logs(rvm_execution_result_t *result,
                                 rvm_log_entry_t *logs_buffer,
                                 size_t buffer_count,
                                 size_t *actual_count);

/**
 * Free execution result
 */
void rvm_execution_result_free(rvm_execution_result_t *result);

/**
 * Estimate gas for transaction
 */
int rvm_estimate_gas(rvm_vm_t *vm,
                    rvm_transaction_t *transaction,
                    uint64_t *estimated_gas);

/**
 * Get VM state root hash
 */
int rvm_vm_get_state_root(rvm_vm_t *vm, uint8_t *root_hash);

/**
 * Commit VM state changes
 */
int rvm_vm_commit_state(rvm_vm_t *vm);

/**
 * Get error message for error code
 */
const char *rvm_error_string(int error_code);

/**
 * Get VM type name
 */
const char *rvm_vm_type_name(int vm_type);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* RVM_H */
```

## C Usage

### Basic C Example

```c
// vm_example.c
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include "rvm.h"

void test_vm_creation();
void test_account_operations();
void test_contract_deployment();
void test_transaction_execution();

int main() {
    printf("RVM version: %s\n", rvm_version_string());

    test_vm_creation();
    test_account_operations();
    test_contract_deployment();
    test_transaction_execution();

    printf("All RVM tests completed!\n");
    return 0;
}

void test_vm_creation() {
    printf("\n=== VM Creation Test ===\n");

    rvm_config_t config = {
        .vm_type = RVM_VM_TYPE_EVM,
        .max_gas_limit = 30000000,
        .max_stack_size = 1024,
        .max_memory_size = 128 * 1024 * 1024,
        .enable_precompiles = 1,
        .enable_debug = 0,
        .gas_price = 20000000000,
        .chain_id = 1,
    };

    rvm_vm_t *vm = rvm_vm_new(&config);
    assert(vm != NULL);

    printf("✓ VM created successfully with type: %s\n",
           rvm_vm_type_name(config.vm_type));

    // Get state root
    uint8_t state_root[32];
    int result = rvm_vm_get_state_root(vm, state_root);
    assert(result == RVM_SUCCESS);
    printf("✓ Initial state root obtained\n");

    rvm_vm_free(vm);
    printf("✓ VM cleaned up successfully\n");
}

void test_account_operations() {
    printf("\n=== Account Operations Test ===\n");

    rvm_config_t config = {
        .vm_type = RVM_VM_TYPE_EVM,
        .max_gas_limit = 30000000,
        .max_stack_size = 1024,
        .max_memory_size = 128 * 1024 * 1024,
        .enable_precompiles = 1,
        .enable_debug = 0,
        .gas_price = 20000000000,
        .chain_id = 1,
    };

    rvm_vm_t *vm = rvm_vm_new(&config);
    assert(vm != NULL);

    // Create account
    uint8_t address[20] = {
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0x12, 0x34, 0x56, 0x78
    };

    uint8_t balance[32] = {0}; // Start with 0 balance
    balance[31] = 100; // Set to 100 wei

    rvm_account_t *account = rvm_account_create(vm, address, balance, 0);
    assert(account != NULL);
    printf("✓ Account created successfully\n");

    // Get account info
    rvm_account_info_t account_info;
    int result = rvm_account_get_info(account, &account_info);
    assert(result == RVM_SUCCESS);

    printf("✓ Account info retrieved:\n");
    printf("  - Address: 0x");
    for (int i = 0; i < 20; i++) {
        printf("%02x", account_info.address[i]);
    }
    printf("\n");
    printf("  - Nonce: %lu\n", account_info.nonce);
    printf("  - Type: %s\n",
           account_info.account_type == RVM_ACCOUNT_TYPE_EOA ? "EOA" : "Contract");

    // Update balance
    uint8_t new_balance[32] = {0};
    new_balance[30] = 1; // 256 wei
    result = rvm_account_set_balance(account, new_balance);
    assert(result == RVM_SUCCESS);
    printf("✓ Account balance updated\n");

    // Increment nonce
    result = rvm_account_increment_nonce(account);
    assert(result == RVM_SUCCESS);
    printf("✓ Account nonce incremented\n");

    rvm_account_free(account);
    rvm_vm_free(vm);
    printf("✓ Account operations completed\n");
}

void test_contract_deployment() {
    printf("\n=== Contract Deployment Test ===\n");

    rvm_config_t config = {
        .vm_type = RVM_VM_TYPE_EVM,
        .max_gas_limit = 30000000,
        .max_stack_size = 1024,
        .max_memory_size = 128 * 1024 * 1024,
        .enable_precompiles = 1,
        .enable_debug = 0,
        .gas_price = 20000000000,
        .chain_id = 1,
    };

    rvm_vm_t *vm = rvm_vm_new(&config);
    assert(vm != NULL);

    // Deployer address
    uint8_t deployer[20] = {
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
        0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
        0x11, 0x22, 0x33, 0x44
    };

    // Simple contract bytecode (example)
    uint8_t bytecode[] = {
        0x60, 0x80, 0x60, 0x40, 0x52, 0x34, 0x80, 0x15,
        0x61, 0x00, 0x10, 0x57, 0x60, 0x00, 0x80, 0xfd,
        0x5b, 0x50, 0x61, 0x00, 0x8f, 0x80, 0x61, 0x00,
        0x1f, 0x60, 0x00, 0x39, 0x60, 0x00, 0xf3, 0xfe
    };

    // Deploy contract
    rvm_contract_t *contract = rvm_contract_deploy(
        vm,
        deployer,
        bytecode,
        sizeof(bytecode),
        NULL, // No constructor args
        0,
        1000000 // Gas limit
    );

    if (contract != NULL) {
        printf("✓ Contract deployed successfully\n");

        // Get contract info
        rvm_contract_info_t contract_info;
        int result = rvm_contract_get_info(contract, &contract_info);
        assert(result == RVM_SUCCESS);

        printf("✓ Contract info retrieved:\n");
        printf("  - Address: 0x");
        for (int i = 0; i < 20; i++) {
            printf("%02x", contract_info.address[i]);
        }
        printf("\n");
        printf("  - Code size: %zu bytes\n", contract_info.code_size);
        printf("  - Created at block: %lu\n", contract_info.created_at_block);

        // Get contract code
        uint8_t code_buffer[1024];
        size_t actual_size;
        result = rvm_contract_get_code(contract, code_buffer, sizeof(code_buffer), &actual_size);
        assert(result == RVM_SUCCESS);
        printf("✓ Contract code retrieved: %zu bytes\n", actual_size);

        rvm_contract_free(contract);
    } else {
        printf("✗ Contract deployment failed\n");
    }

    rvm_vm_free(vm);
    printf("✓ Contract deployment test completed\n");
}

void test_transaction_execution() {
    printf("\n=== Transaction Execution Test ===\n");

    rvm_config_t config = {
        .vm_type = RVM_VM_TYPE_EVM,
        .max_gas_limit = 30000000,
        .max_stack_size = 1024,
        .max_memory_size = 128 * 1024 * 1024,
        .enable_precompiles = 1,
        .enable_debug = 0,
        .gas_price = 20000000000,
        .chain_id = 1,
    };

    rvm_vm_t *vm = rvm_vm_new(&config);
    assert(vm != NULL);

    // Transaction details
    uint8_t from[20] = {
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,
        0x11, 0x11, 0x11, 0x11
    };

    uint8_t to[20] = {
        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
        0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
        0x22, 0x22, 0x22, 0x22
    };

    uint8_t value[32] = {0};
    value[31] = 1; // 1 wei

    uint8_t data[] = {0x12, 0x34, 0x56, 0x78}; // Example data

    // Create transaction
    rvm_transaction_t *tx = rvm_transaction_create(
        RVM_TX_TYPE_CALL,
        from,
        to,
        value,
        21000, // Gas limit
        20000000000, // Gas price (20 gwei)
        0, // Nonce
        data,
        sizeof(data)
    );

    assert(tx != NULL);
    printf("✓ Transaction created successfully\n");

    // Get transaction info
    rvm_transaction_info_t tx_info;
    int result = rvm_transaction_get_info(tx, &tx_info);
    assert(result == RVM_SUCCESS);

    printf("✓ Transaction info:\n");
    printf("  - Type: %s\n",
           tx_info.tx_type == RVM_TX_TYPE_CALL ? "Call" : "Create");
    printf("  - Gas limit: %lu\n", tx_info.gas_limit);
    printf("  - Gas price: %lu\n", tx_info.gas_price);
    printf("  - Data size: %zu bytes\n", tx_info.data_size);

    // Estimate gas
    uint64_t estimated_gas;
    result = rvm_estimate_gas(vm, tx, &estimated_gas);
    if (result == RVM_SUCCESS) {
        printf("✓ Estimated gas: %lu\n", estimated_gas);
    }

    // Execute transaction
    rvm_execution_result_t *exec_result = rvm_transaction_execute(vm, tx);
    if (exec_result != NULL) {
        printf("✓ Transaction executed\n");

        // Get execution info
        rvm_execution_info_t exec_info;
        result = rvm_execution_result_get_info(exec_result, &exec_info);
        assert(result == RVM_SUCCESS);

        printf("✓ Execution result:\n");
        printf("  - Status: %d\n", exec_info.status);
        printf("  - Gas used: %lu\n", exec_info.gas_used);
        printf("  - Gas remaining: %lu\n", exec_info.gas_remaining);
        printf("  - Return data size: %zu bytes\n", exec_info.return_data_size);
        printf("  - Logs count: %zu\n", exec_info.logs_count);

        // Get return data if any
        if (exec_info.return_data_size > 0) {
            uint8_t return_data[1024];
            size_t actual_size;
            result = rvm_execution_result_get_return_data(
                exec_result,
                return_data,
                sizeof(return_data),
                &actual_size
            );
            if (result == RVM_SUCCESS) {
                printf("✓ Return data retrieved: %zu bytes\n", actual_size);
            }
        }

        rvm_execution_result_free(exec_result);
    } else {
        printf("✗ Transaction execution failed\n");
    }

    rvm_transaction_free(tx);
    rvm_vm_free(vm);
    printf("✓ Transaction execution test completed\n");
}
```

## C++ Wrapper

### Modern C++ Wrapper

```cpp
// rvm.hpp
#ifndef RVM_HPP
#define RVM_HPP

#include <string>
#include <vector>
#include <memory>
#include <stdexcept>
#include <array>
#include <cstring>
#include "rvm.h"

namespace rvm {

class VMError : public std::runtime_error {
public:
    explicit VMError(int error_code)
        : std::runtime_error(rvm_error_string(error_code))
        , code_(error_code) {}

    int code() const { return code_; }

private:
    int code_;
};

// Helper class for 256-bit integers
class U256 {
public:
    U256() { data_.fill(0); }

    explicit U256(uint64_t value) {
        data_.fill(0);
        // Store in big-endian format
        for (int i = 7; i >= 0; --i) {
            data_[24 + i] = static_cast<uint8_t>(value & 0xFF);
            value >>= 8;
        }
    }

    explicit U256(const std::array<uint8_t, 32>& bytes) : data_(bytes) {}

    const std::array<uint8_t, 32>& bytes() const { return data_; }

    uint64_t to_u64() const {
        uint64_t result = 0;
        for (int i = 0; i < 8; ++i) {
            result = (result << 8) | data_[24 + i];
        }
        return result;
    }

    std::string to_hex() const {
        std::string result = "0x";
        for (const auto& byte : data_) {
            char buf[3];
            snprintf(buf, sizeof(buf), "%02x", byte);
            result += buf;
        }
        return result;
    }

private:
    std::array<uint8_t, 32> data_;
};

// Helper class for addresses
class Address {
public:
    Address() { data_.fill(0); }

    explicit Address(const std::array<uint8_t, 20>& bytes) : data_(bytes) {}

    static Address from_hex(const std::string& hex_string) {
        // Simplified hex parsing
        Address addr;
        // Implementation would parse hex string
        return addr;
    }

    const std::array<uint8_t, 20>& bytes() const { return data_; }

    std::string to_hex() const {
        std::string result = "0x";
        for (const auto& byte : data_) {
            char buf[3];
            snprintf(buf, sizeof(buf), "%02x", byte);
            result += buf;
        }
        return result;
    }

private:
    std::array<uint8_t, 20> data_;
};

enum class VMType {
    EVM = RVM_VM_TYPE_EVM,
    WASM = RVM_VM_TYPE_WASM,
    Ghost = RVM_VM_TYPE_GHOST,
};

enum class AccountType {
    EOA = RVM_ACCOUNT_TYPE_EOA,
    Contract = RVM_ACCOUNT_TYPE_CONTRACT,
};

enum class TransactionType {
    Call = RVM_TX_TYPE_CALL,
    Create = RVM_TX_TYPE_CREATE,
    Create2 = RVM_TX_TYPE_CREATE2,
};

enum class ExecutionStatus {
    Success = RVM_EXEC_SUCCESS,
    Revert = RVM_EXEC_REVERT,
    OutOfGas = RVM_EXEC_OUT_OF_GAS,
    InvalidOpcode = RVM_EXEC_INVALID_OPCODE,
    StackOverflow = RVM_EXEC_STACK_OVERFLOW,
    StackUnderflow = RVM_EXEC_STACK_UNDERFLOW,
};

struct VMConfig {
    VMType vm_type = VMType::EVM;
    uint64_t max_gas_limit = 30000000;
    uint32_t max_stack_size = 1024;
    uint64_t max_memory_size = 128 * 1024 * 1024;
    bool enable_precompiles = true;
    bool enable_debug = false;
    uint64_t gas_price = 20000000000; // 20 gwei
    uint64_t chain_id = 1;

    rvm_config_t to_native() const {
        return rvm_config_t{
            .vm_type = static_cast<int>(vm_type),
            .max_gas_limit = max_gas_limit,
            .max_stack_size = max_stack_size,
            .max_memory_size = max_memory_size,
            .enable_precompiles = enable_precompiles ? 1 : 0,
            .enable_debug = enable_debug ? 1 : 0,
            .gas_price = gas_price,
            .chain_id = chain_id,
        };
    }
};

struct AccountInfo {
    Address address;
    U256 balance;
    uint64_t nonce;
    AccountType account_type;
    std::array<uint8_t, 32> code_hash;
    std::array<uint8_t, 32> storage_root;

    static AccountInfo from_native(const rvm_account_info_t& native) {
        std::array<uint8_t, 20> addr_bytes;
        std::array<uint8_t, 32> balance_bytes;
        std::array<uint8_t, 32> code_hash_bytes;
        std::array<uint8_t, 32> storage_root_bytes;

        std::copy(native.address, native.address + 20, addr_bytes.begin());
        std::copy(native.balance, native.balance + 32, balance_bytes.begin());
        std::copy(native.code_hash, native.code_hash + 32, code_hash_bytes.begin());
        std::copy(native.storage_root, native.storage_root + 32, storage_root_bytes.begin());

        return AccountInfo{
            .address = Address(addr_bytes),
            .balance = U256(balance_bytes),
            .nonce = native.nonce,
            .account_type = static_cast<AccountType>(native.account_type),
            .code_hash = code_hash_bytes,
            .storage_root = storage_root_bytes,
        };
    }
};

struct TransactionInfo {
    TransactionType tx_type;
    Address from;
    Address to;
    U256 value;
    uint64_t gas_limit;
    uint64_t gas_price;
    uint64_t nonce;
    size_t data_size;

    static TransactionInfo from_native(const rvm_transaction_info_t& native) {
        std::array<uint8_t, 20> from_bytes;
        std::array<uint8_t, 20> to_bytes;
        std::array<uint8_t, 32> value_bytes;

        std::copy(native.from, native.from + 20, from_bytes.begin());
        std::copy(native.to, native.to + 20, to_bytes.begin());
        std::copy(native.value, native.value + 32, value_bytes.begin());

        return TransactionInfo{
            .tx_type = static_cast<TransactionType>(native.tx_type),
            .from = Address(from_bytes),
            .to = Address(to_bytes),
            .value = U256(value_bytes),
            .gas_limit = native.gas_limit,
            .gas_price = native.gas_price,
            .nonce = native.nonce,
            .data_size = native.data_size,
        };
    }
};

struct ExecutionInfo {
    ExecutionStatus status;
    uint64_t gas_used;
    uint64_t gas_remaining;
    size_t return_data_size;
    size_t logs_count;
    Address created_contract;
    size_t revert_reason_size;

    static ExecutionInfo from_native(const rvm_execution_info_t& native) {
        std::array<uint8_t, 20> contract_bytes;
        std::copy(native.created_contract, native.created_contract + 20, contract_bytes.begin());

        return ExecutionInfo{
            .status = static_cast<ExecutionStatus>(native.status),
            .gas_used = native.gas_used,
            .gas_remaining = native.gas_remaining,
            .return_data_size = native.return_data_size,
            .logs_count = native.logs_count,
            .created_contract = Address(contract_bytes),
            .revert_reason_size = native.revert_reason_size,
        };
    }
};

class ExecutionResult {
public:
    explicit ExecutionResult(rvm_execution_result_t* result) : result_(result) {}

    ~ExecutionResult() {
        if (result_) {
            rvm_execution_result_free(result_);
        }
    }

    // Non-copyable
    ExecutionResult(const ExecutionResult&) = delete;
    ExecutionResult& operator=(const ExecutionResult&) = delete;

    // Movable
    ExecutionResult(ExecutionResult&& other) noexcept : result_(other.result_) {
        other.result_ = nullptr;
    }

    ExecutionResult& operator=(ExecutionResult&& other) noexcept {
        if (this != &other) {
            if (result_) {
                rvm_execution_result_free(result_);
            }
            result_ = other.result_;
            other.result_ = nullptr;
        }
        return *this;
    }

    ExecutionInfo get_info() const {
        rvm_execution_info_t info;
        int result = rvm_execution_result_get_info(result_, &info);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
        return ExecutionInfo::from_native(info);
    }

    std::vector<uint8_t> get_return_data() const {
        size_t actual_size;
        int result = rvm_execution_result_get_return_data(result_, nullptr, 0, &actual_size);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }

        std::vector<uint8_t> data(actual_size);
        result = rvm_execution_result_get_return_data(
            result_,
            data.data(),
            data.size(),
            &actual_size
        );

        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }

        return data;
    }

private:
    rvm_execution_result_t* result_;
};

class Account {
public:
    explicit Account(rvm_account_t* account) : account_(account) {}

    ~Account() {
        if (account_) {
            rvm_account_free(account_);
        }
    }

    // Non-copyable
    Account(const Account&) = delete;
    Account& operator=(const Account&) = delete;

    // Movable
    Account(Account&& other) noexcept : account_(other.account_) {
        other.account_ = nullptr;
    }

    Account& operator=(Account&& other) noexcept {
        if (this != &other) {
            if (account_) {
                rvm_account_free(account_);
            }
            account_ = other.account_;
            other.account_ = nullptr;
        }
        return *this;
    }

    AccountInfo get_info() const {
        rvm_account_info_t info;
        int result = rvm_account_get_info(account_, &info);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
        return AccountInfo::from_native(info);
    }

    void set_balance(const U256& balance) {
        int result = rvm_account_set_balance(account_, balance.bytes().data());
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
    }

    void increment_nonce() {
        int result = rvm_account_increment_nonce(account_);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
    }

    rvm_account_t* native() const { return account_; }

private:
    rvm_account_t* account_;
};

class Contract {
public:
    explicit Contract(rvm_contract_t* contract) : contract_(contract) {}

    ~Contract() {
        if (contract_) {
            rvm_contract_free(contract_);
        }
    }

    // Non-copyable
    Contract(const Contract&) = delete;
    Contract& operator=(const Contract&) = delete;

    // Movable
    Contract(Contract&& other) noexcept : contract_(other.contract_) {
        other.contract_ = nullptr;
    }

    Contract& operator=(Contract&& other) noexcept {
        if (this != &other) {
            if (contract_) {
                rvm_contract_free(contract_);
            }
            contract_ = other.contract_;
            other.contract_ = nullptr;
        }
        return *this;
    }

    std::vector<uint8_t> get_code() const {
        size_t actual_size;
        int result = rvm_contract_get_code(contract_, nullptr, 0, &actual_size);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }

        std::vector<uint8_t> code(actual_size);
        result = rvm_contract_get_code(
            contract_,
            code.data(),
            code.size(),
            &actual_size
        );

        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }

        return code;
    }

    rvm_contract_t* native() const { return contract_; }

private:
    rvm_contract_t* contract_;
};

class Transaction {
public:
    explicit Transaction(rvm_transaction_t* transaction) : transaction_(transaction) {}

    ~Transaction() {
        if (transaction_) {
            rvm_transaction_free(transaction_);
        }
    }

    // Non-copyable
    Transaction(const Transaction&) = delete;
    Transaction& operator=(const Transaction&) = delete;

    // Movable
    Transaction(Transaction&& other) noexcept : transaction_(other.transaction_) {
        other.transaction_ = nullptr;
    }

    Transaction& operator=(Transaction&& other) noexcept {
        if (this != &other) {
            if (transaction_) {
                rvm_transaction_free(transaction_);
            }
            transaction_ = other.transaction_;
            other.transaction_ = nullptr;
        }
        return *this;
    }

    TransactionInfo get_info() const {
        rvm_transaction_info_t info;
        int result = rvm_transaction_get_info(transaction_, &info);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
        return TransactionInfo::from_native(info);
    }

    rvm_transaction_t* native() const { return transaction_; }

private:
    rvm_transaction_t* transaction_;
};

class VM {
public:
    explicit VM(const VMConfig& config = VMConfig{})
        : vm_(rvm_vm_new(&config.to_native())) {
        if (!vm_) {
            throw VMError(RVM_ERROR_OUT_OF_MEMORY);
        }
    }

    ~VM() {
        if (vm_) {
            rvm_vm_free(vm_);
        }
    }

    // Non-copyable
    VM(const VM&) = delete;
    VM& operator=(const VM&) = delete;

    // Movable
    VM(VM&& other) noexcept : vm_(other.vm_) {
        other.vm_ = nullptr;
    }

    VM& operator=(VM&& other) noexcept {
        if (this != &other) {
            if (vm_) {
                rvm_vm_free(vm_);
            }
            vm_ = other.vm_;
            other.vm_ = nullptr;
        }
        return *this;
    }

    std::unique_ptr<Account> create_account(
        const Address& address,
        const U256& balance = U256(0),
        uint64_t nonce = 0
    ) {
        rvm_account_t* account = rvm_account_create(
            vm_,
            address.bytes().data(),
            balance.bytes().data(),
            nonce
        );

        if (!account) {
            throw VMError(RVM_ERROR_EXECUTION_FAILED);
        }

        return std::make_unique<Account>(account);
    }

    std::unique_ptr<Contract> deploy_contract(
        const Address& deployer,
        const std::vector<uint8_t>& bytecode,
        const std::vector<uint8_t>& constructor_args = {},
        uint64_t gas_limit = 1000000
    ) {
        rvm_contract_t* contract = rvm_contract_deploy(
            vm_,
            deployer.bytes().data(),
            bytecode.data(),
            bytecode.size(),
            constructor_args.empty() ? nullptr : constructor_args.data(),
            constructor_args.size(),
            gas_limit
        );

        if (!contract) {
            throw VMError(RVM_ERROR_EXECUTION_FAILED);
        }

        return std::make_unique<Contract>(contract);
    }

    std::unique_ptr<ExecutionResult> call_contract(
        Contract& contract,
        const Address& caller,
        const std::vector<uint8_t>& function_data = {},
        const U256& value = U256(0),
        uint64_t gas_limit = 100000
    ) {
        rvm_execution_result_t* result = rvm_contract_call(
            vm_,
            contract.native(),
            caller.bytes().data(),
            function_data.empty() ? nullptr : function_data.data(),
            function_data.size(),
            value.bytes().data(),
            gas_limit
        );

        if (!result) {
            throw VMError(RVM_ERROR_EXECUTION_FAILED);
        }

        return std::make_unique<ExecutionResult>(result);
    }

    std::unique_ptr<Transaction> create_transaction(
        TransactionType tx_type,
        const Address& from,
        const Address& to,
        const U256& value = U256(0),
        uint64_t gas_limit = 21000,
        uint64_t gas_price = 20000000000,
        uint64_t nonce = 0,
        const std::vector<uint8_t>& data = {}
    ) {
        rvm_transaction_t* transaction = rvm_transaction_create(
            static_cast<int>(tx_type),
            from.bytes().data(),
            to.bytes().data(),
            value.bytes().data(),
            gas_limit,
            gas_price,
            nonce,
            data.empty() ? nullptr : data.data(),
            data.size()
        );

        if (!transaction) {
            throw VMError(RVM_ERROR_EXECUTION_FAILED);
        }

        return std::make_unique<Transaction>(transaction);
    }

    std::unique_ptr<ExecutionResult> execute_transaction(Transaction& transaction) {
        rvm_execution_result_t* result = rvm_transaction_execute(vm_, transaction.native());

        if (!result) {
            throw VMError(RVM_ERROR_EXECUTION_FAILED);
        }

        return std::make_unique<ExecutionResult>(result);
    }

    uint64_t estimate_gas(Transaction& transaction) {
        uint64_t estimated_gas;
        int result = rvm_estimate_gas(vm_, transaction.native(), &estimated_gas);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
        return estimated_gas;
    }

    std::array<uint8_t, 32> get_state_root() const {
        std::array<uint8_t, 32> root_hash;
        int result = rvm_vm_get_state_root(vm_, root_hash.data());
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
        return root_hash;
    }

    void commit_state() {
        int result = rvm_vm_commit_state(vm_);
        if (result != RVM_SUCCESS) {
            throw VMError(result);
        }
    }

private:
    rvm_vm_t* vm_;
};

// Utility functions
inline std::string version() {
    return std::string(rvm_version_string());
}

inline std::string vm_type_name(VMType vm_type) {
    return std::string(rvm_vm_type_name(static_cast<int>(vm_type)));
}

} // namespace rvm

#endif // RVM_HPP
```

### C++ Usage Example

```cpp
// example.cpp
#include <iostream>
#include <iomanip>
#include "rvm.hpp"

void test_vm_operations();
void test_account_management();
void test_contract_operations();
void test_transaction_execution();

int main() {
    try {
        std::cout << "RVM version: " << rvm::version() << std::endl;

        test_vm_operations();
        test_account_management();
        test_contract_operations();
        test_transaction_execution();

    } catch (const rvm::VMError& e) {
        std::cerr << "VM error: " << e.what() << " (code: " << e.code() << ")" << std::endl;
        return 1;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }

    std::cout << "All RVM tests completed!" << std::endl;
    return 0;
}

void test_vm_operations() {
    std::cout << "\n=== VM Operations Test ===" << std::endl;

    rvm::VMConfig config;
    config.vm_type = rvm::VMType::EVM;
    config.max_gas_limit = 30000000;
    config.enable_debug = true;
    config.chain_id = 1337;

    rvm::VM vm(config);
    std::cout << "✓ VM created with type: "
              << rvm::vm_type_name(config.vm_type) << std::endl;

    auto state_root = vm.get_state_root();
    std::cout << "✓ State root: 0x";
    for (const auto& byte : state_root) {
        std::cout << std::hex << std::setfill('0') << std::setw(2) << static_cast<int>(byte);
    }
    std::cout << std::dec << std::endl;
}

void test_account_management() {
    std::cout << "\n=== Account Management Test ===" << std::endl;

    rvm::VM vm;

    // Create an address
    std::array<uint8_t, 20> addr_bytes;
    std::fill(addr_bytes.begin(), addr_bytes.end(), 0x42);
    rvm::Address address(addr_bytes);

    // Create account with initial balance
    rvm::U256 initial_balance(1000000000000000000ULL); // 1 ETH in wei
    auto account = vm.create_account(address, initial_balance, 0);

    std::cout << "✓ Account created with address: " << address.to_hex() << std::endl;

    auto account_info = account->get_info();
    std::cout << "✓ Account info:" << std::endl;
    std::cout << "  - Balance: " << account_info.balance.to_u64() << " wei" << std::endl;
    std::cout << "  - Nonce: " << account_info.nonce << std::endl;
    std::cout << "  - Type: " << (account_info.account_type == rvm::AccountType::EOA ? "EOA" : "Contract") << std::endl;

    // Update balance
    rvm::U256 new_balance(2000000000000000000ULL); // 2 ETH
    account->set_balance(new_balance);
    std::cout << "✓ Account balance updated" << std::endl;

    // Increment nonce
    account->increment_nonce();
    std::cout << "✓ Account nonce incremented" << std::endl;

    // Verify changes
    auto updated_info = account->get_info();
    std::cout << "✓ Updated balance: " << updated_info.balance.to_u64() << " wei" << std::endl;
    std::cout << "✓ Updated nonce: " << updated_info.nonce << std::endl;
}

void test_contract_operations() {
    std::cout << "\n=== Contract Operations Test ===" << std::endl;

    rvm::VM vm;

    // Create deployer address
    std::array<uint8_t, 20> deployer_bytes;
    std::iota(deployer_bytes.begin(), deployer_bytes.end(), 1);
    rvm::Address deployer(deployer_bytes);

    // Simple contract bytecode (example)
    std::vector<uint8_t> bytecode = {
        0x60, 0x80, 0x60, 0x40, 0x52, 0x34, 0x80, 0x15,
        0x61, 0x00, 0x10, 0x57, 0x60, 0x00, 0x80, 0xfd,
        0x5b, 0x50, 0x61, 0x00, 0x8f, 0x80, 0x61, 0x00,
        0x1f, 0x60, 0x00, 0x39, 0x60, 0x00, 0xf3, 0xfe
    };

    try {
        // Deploy contract
        auto contract = vm.deploy_contract(deployer, bytecode, {}, 1000000);
        std::cout << "✓ Contract deployed successfully" << std::endl;

        // Get contract code
        auto deployed_code = contract->get_code();
        std::cout << "✓ Contract code retrieved: " << deployed_code.size() << " bytes" << std::endl;

        // Call contract function (example)
        std::vector<uint8_t> function_data = {0x12, 0x34, 0x56, 0x78};
        auto call_result = vm.call_contract(*contract, deployer, function_data, rvm::U256(0), 100000);

        auto exec_info = call_result->get_info();
        std::cout << "✓ Contract call executed:" << std::endl;
        std::cout << "  - Status: " << static_cast<int>(exec_info.status) << std::endl;
        std::cout << "  - Gas used: " << exec_info.gas_used << std::endl;

        auto return_data = call_result->get_return_data();
        std::cout << "  - Return data size: " << return_data.size() << " bytes" << std::endl;

    } catch (const rvm::VMError& e) {
        std::cout << "✗ Contract operation failed: " << e.what() << std::endl;
    }
}

void test_transaction_execution() {
    std::cout << "\n=== Transaction Execution Test ===" << std::endl;

    rvm::VM vm;

    // Create addresses
    std::array<uint8_t, 20> from_bytes, to_bytes;
    std::fill(from_bytes.begin(), from_bytes.end(), 0x11);
    std::fill(to_bytes.begin(), to_bytes.end(), 0x22);

    rvm::Address from_addr(from_bytes);
    rvm::Address to_addr(to_bytes);

    // Create accounts
    auto from_account = vm.create_account(from_addr, rvm::U256(1000000000000000000ULL)); // 1 ETH
    auto to_account = vm.create_account(to_addr, rvm::U256(0));

    std::cout << "✓ Accounts created for transaction test" << std::endl;

    // Create transaction
    rvm::U256 transfer_amount(100000000000000000ULL); // 0.1 ETH
    std::vector<uint8_t> tx_data = {0xde, 0xad, 0xbe, 0xef};

    auto transaction = vm.create_transaction(
        rvm::TransactionType::Call,
        from_addr,
        to_addr,
        transfer_amount,
        21000,       // Gas limit
        20000000000, // Gas price (20 gwei)
        0,           // Nonce
        tx_data
    );

    std::cout << "✓ Transaction created" << std::endl;

    auto tx_info = transaction->get_info();
    std::cout << "✓ Transaction info:" << std::endl;
    std::cout << "  - Type: " << (tx_info.tx_type == rvm::TransactionType::Call ? "Call" : "Create") << std::endl;
    std::cout << "  - From: " << tx_info.from.to_hex() << std::endl;
    std::cout << "  - To: " << tx_info.to.to_hex() << std::endl;
    std::cout << "  - Value: " << tx_info.value.to_u64() << " wei" << std::endl;
    std::cout << "  - Gas limit: " << tx_info.gas_limit << std::endl;

    // Estimate gas
    try {
        uint64_t estimated_gas = vm.estimate_gas(*transaction);
        std::cout << "✓ Estimated gas: " << estimated_gas << std::endl;
    } catch (const rvm::VMError& e) {
        std::cout << "✗ Gas estimation failed: " << e.what() << std::endl;
    }

    // Execute transaction
    try {
        auto exec_result = vm.execute_transaction(*transaction);
        auto exec_info = exec_result->get_info();

        std::cout << "✓ Transaction executed:" << std::endl;
        std::cout << "  - Status: " << static_cast<int>(exec_info.status) << std::endl;
        std::cout << "  - Gas used: " << exec_info.gas_used << std::endl;
        std::cout << "  - Gas remaining: " << exec_info.gas_remaining << std::endl;

        if (exec_info.status == rvm::ExecutionStatus::Success) {
            std::cout << "✓ Transaction executed successfully" << std::endl;

            // Commit state changes
            vm.commit_state();
            std::cout << "✓ State changes committed" << std::endl;
        } else {
            std::cout << "✗ Transaction failed with status: " << static_cast<int>(exec_info.status) << std::endl;
        }

    } catch (const rvm::VMError& e) {
        std::cout << "✗ Transaction execution failed: " << e.what() << std::endl;
    }
}
```

## CMake Integration

### CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)
project(rvm_example)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Find the RVM library
find_library(RVM_LIBRARY
    NAMES rvm_c
    PATHS ${CMAKE_SOURCE_DIR}/target/release
    REQUIRED
)

# Find the RVM headers
find_path(RVM_INCLUDE_DIR
    NAMES rvm.h
    PATHS ${CMAKE_SOURCE_DIR}/include
    REQUIRED
)

# Create imported target
add_library(rvm::rvm UNKNOWN IMPORTED)
set_target_properties(rvm::rvm PROPERTIES
    IMPORTED_LOCATION ${RVM_LIBRARY}
    INTERFACE_INCLUDE_DIRECTORIES ${RVM_INCLUDE_DIR}
)

# C example
add_executable(c_vm vm_example.c)
target_link_libraries(c_vm
    rvm::rvm
    pthread
    dl
    m
)

# C++ example
add_executable(cpp_vm example.cpp)
target_link_libraries(cpp_vm
    rvm::rvm
    pthread
    dl
    m
)

# Custom target to build Rust library
add_custom_target(build_rust_lib
    COMMAND cargo build --release
    WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
    COMMENT "Building Rust RVM library"
)

# Make sure Rust library is built before our targets
add_dependencies(c_vm build_rust_lib)
add_dependencies(cpp_vm build_rust_lib)
```

This completes the RVM C/C++ integration guide. The bindings provide comprehensive virtual machine functionality with smart contract deployment, execution, and state management while maintaining the security and performance characteristics of the Rust implementation.